#!/usr/bin/env python
import os
import sys
import shutil
import asyncio
from pathlib import Path
from math import ceil

import aiohttp
import aiohttp_retry
from lxml import etree


WEBLATE_API = "https://hosted.weblate.org/api"
PROJECT_SLUG = "gramophone"
API_TOKEN = os.getenv("WEBLATE_TOKEN")
HEADERS = {
    "Authorization": f"Token {API_TOKEN}",
    "Accept": "application/json",
}
MAX_RETRIES = 4

UNITS_COUNT: int | None = None


async def get_languages(session: aiohttp.ClientSession, component_slug: str) -> list:
    url = f"{WEBLATE_API}/components/{PROJECT_SLUG}/{component_slug}/translations/"
    async with session.get(url, headers=HEADERS) as response:
        result = await response.json()
        languages = result.get('results')
    return languages


async def get_page_units(session: aiohttp.ClientSession, page: int, language_code: str) -> list:
    url = f"{WEBLATE_API}/translations/{PROJECT_SLUG}/strings-xml/{language_code}/units/"
    async with session.get(url, headers=HEADERS, params={'page': page}) as response:
        data = await response.json()
        return data.get("results")


async def get_units_list(session: aiohttp.ClientSession, language_code: str, component_slug: str) -> list:
    global UNITS_COUNT
    url = f"{WEBLATE_API}/translations/{PROJECT_SLUG}/{component_slug}/{language_code}/units/"
    units = []

    print(f'\nGetting {component_slug} units of language code "{language_code}"... ', end="")
    # every weblate units data page has at most 50 units in results
    if not UNITS_COUNT or UNITS_COUNT <= 50:
        # if UNITS_COUNT is not assigned make a single request and assign it
        async with session.get(url, headers=HEADERS) as response:
            data = await response.json()
            units.extend(data.get("results"))
            UNITS_COUNT = data.get("count")

    if UNITS_COUNT > 50:
        # if units is not empty it means page 1's request has been sent
        # to get UNITS_COUNT so it should start from page 2
        start_page = 1 if not units else 2
        pages_count = ceil(UNITS_COUNT / 50)
        pages_params = [{'page': i, 'language_code': language_code}
                        for i in range(start_page, pages_count + 1)]
        tasks = [get_page_units(session, **page_param) for page_param in pages_params]
        for future in asyncio.as_completed(tasks):
            units.extend(await future)

    print(f"Got {len(units)} units.")
    return units


def delete_strings(xml_file: Path, names_to_delete: list[str]) -> None:
    """
    Deletes entire <string> elements from Android string resources XML
    while preserving all formatting, comments, and XML structure
    """
    # Create parser with full preservation settings
    parser = etree.XMLParser(
        remove_blank_text=False,
        remove_comments=False,
        remove_pis=False,
        strip_cdata=False,
        resolve_entities=False
    )

    source_file_path = Path(sys.argv[1]).joinpath(xml_file)
    tree = etree.parse(source_file_path, parser)
    if names_to_delete:
        root = tree.getroot()

        # Find all string elements
        print("  Deleting: ", end="")
        for elem in root.xpath('//string | //plurals | //string-array'):
            name = elem.get('name')
            if name in names_to_delete:
                parent = elem.getparent()
                parent.remove(elem)
                print(name, end=", ")
        print()
    else:
        print(f"  No strings to delete in {xml_file}.")

    tree.write(
        str(xml_file),
        encoding='utf-8',
        xml_declaration=True,
        pretty_print=False,
        with_comments=True,
        method="xml"
    )
    print(f"  Updated XML file: {xml_file}")


async def filter_editings(session: aiohttp.ClientSession, language_code: str, component_slug: str) -> list[str]:
    units = await get_units_list(session, language_code, component_slug)
    string_names = [u.get('context') for u in units if u.get('state') == 10]
    print(f"  Strings to delete: {string_names}")
    return string_names


def manage_fastlane_files(files_path: Path, editings: list[str]) -> None:
    """Deletes all of the files if any of them is missing or needs editing"""
    source_files_path = Path(sys.argv[1]).joinpath(files_path)
    if not source_files_path.exists():
        print(f"  Fastlane directory does not exist: {source_files_path}")
        return

    if sys.argv[1] != os.getcwd():
        if Path(files_path).exists():
            shutil.rmtree(files_path)
        shutil.copytree(source_files_path, files_path)

    if not source_files_path.joinpath('title.txt').exists():
        with open(Path(files_path).joinpath('title.txt'), 'w') as title_file:
            title_file.write('Gramophone')

    files = ["short_description.txt", "full_description.txt"]
    needs_edit = any(file.split(":")[0] in files + ["title.txt"] for file in editings)
    all_exist = all(source_files_path.joinpath(f).exists() for f in files)
    delete_files = not all_exist or needs_edit
    if not delete_files:
        print("  Skipped deleting")
        return

    print(f"  Deleting files in {files_path}")
    for file in files + ["title.txt"]:
        file_path = files_path.joinpath(file)
        if file_path.exists():
            os.remove(file_path)


async def filter_strings_xml(session: aiohttp.ClientSession):
    global UNITS_COUNT
    UNITS_COUNT = None
    languages = await get_languages(session, "strings-xml")
    for language in languages:
        if language.get('is_source'):
            continue
        language_code = language.get('language').get('code')
        xml_file = Path(language.get('filename'))
        editings = await filter_editings(session, language_code, "strings-xml")
        delete_strings(xml_file, editings)


async def filter_fastlane(session: aiohttp.ClientSession):
    global UNITS_COUNT
    UNITS_COUNT = None
    fastlane_languages = await get_languages(session, 'fastlane')
    for language in fastlane_languages:
        if language.get("is_source"):
            continue
        language_code = language.get('language').get('code')
        files_path = Path(language.get('filename'))
        editings = await filter_editings(session, language_code, "fastlane")
        manage_fastlane_files(files_path, editings)


async def main():
    if not API_TOKEN:
        print("$WEBLATE_TOKEN environment variable is not set!")
        sys.exit(1)

    retry_options = aiohttp_retry.ExponentialRetry(
        attempts=MAX_RETRIES,
        start_timeout=1,
        max_timeout=8,
        factor=2,
    )
    async with aiohttp_retry.RetryClient(raise_for_status=False, retry_options=retry_options) as client:
        print("Filtering strings-xml...")
        await filter_strings_xml(client)

        print("\n\nFiltering fastlane...")
        await filter_fastlane(client)


if __name__ == "__main__":
    asyncio.run(main())
